#lang racket

(define all (set 1 2 3 4 5 6 7 8 9))

(define (tile-solved? t) (= 1 (set-count t)))

(define (transform matrix) 
  (map 
   (lambda (lst) 
     (map
      (lambda (num) (
         if (equal? num 0) all (set num))
        )
      lst))
   matrix))

(define (transformflat matrix) 
  (map 
      (lambda (num) (
         if (equal? num 0) all (set num))
        )
   (flatten matrix)))

(struct tile (row col box values) #:transparent)

(define (tile-relevant? tile row col box)
  (and (or (equal? row (tile-row tile)) (equal? col (tile-col tile)) (equal? box (tile-box tile)))
       (not (and (equal? row (tile-row tile)) (equal? col (tile-col tile)) (equal? box (tile-box tile))))))

(define (get-row pos) (quotient pos 9))
(define (get-col pos) (- pos (* 9 (get-row pos))))
(define (get-box pos) (+ (quotient (get-col pos) 3) (* 3 (quotient (get-row pos) 3))))

(define (make-tile value pos) 
  (if (equal? value 0) 
      (tile (get-row pos) 
            (get-col pos) 
            (get-box pos) all) 
      (tile (get-row pos) 
            (get-col pos) 
            (get-box pos) (set value))))

(define (map-with-index f lst) 
   (let iter ([index-list (range 0 (length lst))]
              [in-list lst]
              [out-list (list)])
     (if (null? in-list)
         (reverse out-list)
         (iter (cdr index-list)
               (cdr in-list)
               (cons (f (car in-list) (car index-list)) out-list)))))
  

(define (transform-tile matrix) 
  (map-with-index make-tile (flatten matrix)))

(define (tile-values-to-element tile)
  (let ((values (tile-values tile)))
    (if (equal? 1 (set-count values))
        (set-first values)
        values)))

(define (extract-row-values row board)
  (let iter ([car-tile (car board)]
             [part-board (cdr board)]
             [acc '()])
    (let ((new-acc (if (equal? row (tile-row car-tile))
                       (cons (tile-values-to-element car-tile) acc)
                       acc)))
      (if (null? part-board)
          (reverse new-acc)
          (iter (car part-board) 
                  (cdr part-board)
                  new-acc)))))
    

(define (untransform-tile board)
  (let iter ([matrix (list)]
             [row 8])
    (if (> 0 row)
        matrix
        (iter (cons (extract-row-values row board) matrix) (- row 1)))))
   


(define (test-matrix)
  (list
   (list 0 2 0 1 7 8 0 3 0)
   (list 0 4 0 3 0 2 0 9 0)
   (list 1 0 0 0 0 0 0 0 6)
   (list 0 0 8 6 0 3 5 0 0)
   (list 3 0 0 0 0 0 0 0 4)
   (list 0 0 6 7 0 9 2 0 0)
   (list 9 0 0 0 0 0 0 0 2)
   (list 0 8 0 9 0 1 0 6 0)
   (list 0 1 0 4 3 6 0 5 0)))

(define (test-board)
  (list
 (tile 0 0 0 (set 1 2 3 4 5 6 7 8 9))
 (tile 0 1 0 (set 2))
 (tile 0 2 0 (set 1 2 3 4 5 6 7 8 9))
 (tile 0 3 1 (set 1))
 (tile 0 4 1 (set 7))
 (tile 0 5 1 (set 8))
 (tile 0 6 2 (set 1 2 3 4 5 6 7 8 9))
 (tile 0 7 2 (set 3))
 (tile 0 8 2 (set 1 2 3 4 5 6 7 8 9))
 (tile 1 0 0 (set 1 2 3 4 5 6 7 8 9))
 (tile 1 1 0 (set 4))
 (tile 1 2 0 (set 1 2 3 4 5 6 7 8 9))
 (tile 1 3 1 (set 3))
 (tile 1 4 1 (set 1 2 3 4 5 6 7 8 9))
 (tile 1 5 1 (set 2))
 (tile 1 6 2 (set 1 2 3 4 5 6 7 8 9))
 (tile 1 7 2 (set 9))
 (tile 1 8 2 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 0 0 (set 1))
 (tile 2 1 0 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 2 0 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 3 1 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 4 1 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 5 1 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 6 2 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 7 2 (set 1 2 3 4 5 6 7 8 9))
 (tile 2 8 2 (set 6))
 (tile 3 0 3 (set 1 2 3 4 5 6 7 8 9))
 (tile 3 1 3 (set 1 2 3 4 5 6 7 8 9))
 (tile 3 2 3 (set 8))
 (tile 3 3 4 (set 6))
 (tile 3 4 4 (set 1 2 3 4 5 6 7 8 9))
 (tile 3 5 4 (set 3))
 (tile 3 6 5 (set 5))
 (tile 3 7 5 (set 1 2 3 4 5 6 7 8 9))
 (tile 3 8 5 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 0 3 (set 3))
 (tile 4 1 3 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 2 3 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 3 4 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 4 4 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 5 4 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 6 5 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 7 5 (set 1 2 3 4 5 6 7 8 9))
 (tile 4 8 5 (set 4))
 (tile 5 0 3 (set 1 2 3 4 5 6 7 8 9))
 (tile 5 1 3 (set 1 2 3 4 5 6 7 8 9))
 (tile 5 2 3 (set 6))
 (tile 5 3 4 (set 7))
 (tile 5 4 4 (set 1 2 3 4 5 6 7 8 9))
 (tile 5 5 4 (set 9))
 (tile 5 6 5 (set 2))
 (tile 5 7 5 (set 1 2 3 4 5 6 7 8 9))
 (tile 5 8 5 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 0 6 (set 9))
 (tile 6 1 6 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 2 6 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 3 7 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 4 7 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 5 7 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 6 8 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 7 8 (set 1 2 3 4 5 6 7 8 9))
 (tile 6 8 8 (set 2))
 (tile 7 0 6 (set 1 2 3 4 5 6 7 8 9))
 (tile 7 1 6 (set 8))
 (tile 7 2 6 (set 1 2 3 4 5 6 7 8 9))
 (tile 7 3 7 (set 9))
 (tile 7 4 7 (set 1 2 3 4 5 6 7 8 9))
 (tile 7 5 7 (set 1))
 (tile 7 6 8 (set 1 2 3 4 5 6 7 8 9))
 (tile 7 7 8 (set 6))
 (tile 7 8 8 (set 1 2 3 4 5 6 7 8 9))
 (tile 8 0 6 (set 1 2 3 4 5 6 7 8 9))
 (tile 8 1 6 (set 1))
 (tile 8 2 6 (set 1 2 3 4 5 6 7 8 9))
 (tile 8 3 7 (set 4))
 (tile 8 4 7 (set 3))
 (tile 8 5 7 (set 6))
 (tile 8 6 8 (set 1 2 3 4 5 6 7 8 9))
 (tile 8 7 8 (set 5))
 (tile 8 8 8 (set 1 2 3 4 5 6 7 8 9))))


(provide test-matrix test-board all tile-solved? transform transformflat tile tile-row tile-col tile-box tile-values get-row get-col get-box tile-relevant? make-tile transform-tile untransform-tile)